
from cryptography.hazmat.primitives.asymmetric import ec, rsa
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding

# Generate ECDSA key pair
ecdsa_private_key = ec.generate_private_key(ec.SECP256R1())
ecdsa_public_key = ecdsa_private_key.public_key()

# Generate RSA key pair
rsa_private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048
)
rsa_public_key = rsa_private_key.public_key()

from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric.utils import Prehashed
import base64

# Example data: A list of 5 lists
data = [["Hello, World!"], ["Data Science"], ["Hybrid Encryption"], ["Cryptography"], ["Python"]]


# Function to encrypt data using RSA public key
def encrypt_data_rsa(public_key, plaintext):
    ciphertext = public_key.encrypt(
        plaintext.encode('utf-8'),
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return base64.b64encode(ciphertext).decode('utf-8')


# Function to sign data using ECDSA private key
def sign_data_ecdsa(private_key, data):
    signature = private_key.sign(
        data.encode('utf-8'),
        ec.ECDSA(hashes.SHA256())
    )
    return base64.b64encode(signature).decode('utf-8')


# Encrypt and sign each sublist of data
encrypted_data = []
signatures = []
for sublist in data:
    encrypted_sublist = [encrypt_data_rsa(rsa_public_key, item) for item in sublist]
    encrypted_data.append(encrypted_sublist)

    # Join encrypted sublist into a single string for signing
    data_str = ' '.join(encrypted_sublist)
    signature = sign_data_ecdsa(ecdsa_private_key, data_str)
    signatures.append(signature)

print("Encrypted Data:", encrypted_data)
print("Signatures:", signatures)


# Function to decrypt data using RSA private key
def decrypt_data_rsa(private_key, ciphertext):
    ciphertext_bytes = base64.b64decode(ciphertext.encode('utf-8'))
    plaintext = private_key.decrypt(
        ciphertext_bytes,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return plaintext.decode('utf-8')


# Function to verify data using ECDSA public key
def verify_signature_ecdsa(public_key, data, signature):
    signature_bytes = base64.b64decode(signature.encode('utf-8'))
    try:
        public_key.verify(
            signature_bytes,
            data.encode('utf-8'),
            ec.ECDSA(hashes.SHA256())
        )
        return True
    except Exception as e:
        print(f"Verification failed: {e}")
        return False


# Decrypt and verify each sublist of data
decrypted_data = []
for i, encrypted_sublist in enumerate(encrypted_data):
    decrypted_sublist = [decrypt_data_rsa(rsa_private_key, item) for item in encrypted_sublist]
    decrypted_data.append(decrypted_sublist)

    # Join decrypted sublist into a single string for signature verification
    data_str = ' '.join(encrypted_sublist)
    if verify_signature_ecdsa(ecdsa_public_key, data_str, signatures[i]):
        print(f"Data at index {i} is verified.")
    else:
        print(f"Data at index {i} is not verified.")

print("Decrypted Data:", decrypted_data)



#-------------------------------------proxy -------------------------------------
"""
To implement a proxy-based signature authentication scheme specifically for your type of data (which is a list of lists), we will focus on enabling a proxy signer to sign data on behalf of the original signer. This scheme will ensure that the proxy signature can be authenticated by anyone who trusts the original signer.

Key Components of Proxy-Based Signature Authentication Scheme
Original Signer: The entity that owns the data and delegates signing authority.
Proxy Signer: The entity that receives delegated authority from the original signer and signs data on their behalf.
Delegation Signature: A signature that certifies that the proxy signer has been granted the authority to sign by the original signer.
Proxy Signature: The actual signature generated by the proxy signer for a specific message or piece of data.
Verification: Ensures that the proxy signature is valid and that it was authorized by the original signer.
Implementation Steps
Generate Keys:

Original Signer: Generates an ECDSA key pair.
Proxy Signer: Generates a separate ECDSA key pair.
Create a Delegation Signature:

The Original Signer creates a delegation signature authorizing the Proxy Signer to sign messages on their behalf.
Proxy Signing:

The Proxy Signer signs the data (or list of lists) with their private key.
Verification:

The Verifier (or recipient) uses both the original signer’s public key and the proxy signer’s public key to verify the proxy signature and ensure that it is valid and properly authorized."""
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
import base64

# Generate ECDSA key pair for the original signer
original_private_key = ec.generate_private_key(ec.SECP256R1())
original_public_key = original_private_key.public_key()

# Generate ECDSA key pair for the proxy signer
proxy_private_key = ec.generate_private_key(ec.SECP256R1())
proxy_public_key = proxy_private_key.public_key()

# Function to serialize public keys for storage or transmission
def serialize_public_key(key):
    return key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    ).decode('utf-8')

# Display serialized public keys (optional)
print("Original Signer Public Key:\n", serialize_public_key(original_public_key))
print("Proxy Signer Public Key:\n", serialize_public_key(proxy_public_key))



# Function to sign data using ECDSA private key
def sign_data_ecdsa(private_key, data):
    signature = private_key.sign(
        data.encode('utf-8'),
        ec.ECDSA(hashes.SHA256())
    )
    return base64.b64encode(signature).decode('utf-8')

# Create delegation data and signature
delegation_message = "Delegation from Original Signer to Proxy Signer: " + serialize_public_key(proxy_public_key)
delegation_signature = sign_data_ecdsa(original_private_key, delegation_message)

print("Delegation Signature:", delegation_signature)



# Example data: A list of 5 lists
data = [["Hello, World!"], ["Data Science"], ["Hybrid Encryption"], ["Cryptography"], ["Python"]]

# Function to serialize data
def serialize_data(data):
    return str(data)

# Function to sign data using the proxy signer's ECDSA private key
def proxy_sign_message(proxy_private_key, message):
    return sign_data_ecdsa(proxy_private_key, message)

# Sign each sublist of data
proxy_signatures = []
for sublist in data:
    # Serialize the sublist for signing
    data_str = serialize_data(sublist)
    # Proxy signer signs the serialized data
    signature = proxy_sign_message(proxy_private_key, data_str)
    proxy_signatures.append((data_str, signature))

print("Proxy Signatures:", proxy_signatures)


from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization

# Function to verify data using ECDSA public key
def verify_signature_ecdsa(public_key, data, signature):
    signature_bytes = base64.b64decode(signature.encode('utf-8'))
    try:
        public_key.verify(
            signature_bytes,
            data.encode('utf-8'),
            ec.ECDSA(hashes.SHA256())
        )
        return True
    except Exception as e:
        print(f"Verification failed: {e}")
        return False

# Verify the delegation signature using the original signer's public key
if verify_signature_ecdsa(original_public_key, delegation_message, delegation_signature):
    print("Delegation Signature Verified: The Proxy is authorized.")

    # Verify each proxy signature using the proxy signer's public key
    for data_str, signature in proxy_signatures:
        if verify_signature_ecdsa(proxy_public_key, data_str, signature):
            print(f"Proxy Signature Verified for data: {data_str}")
        else:
            print(f"Proxy Signature Verification Failed for data: {data_str}")
else:
    print("Delegation Signature Verification Failed: Unauthorized Proxy.")
